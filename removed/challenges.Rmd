--- type:ChallengeExercise lang:r xp:200 skills:1
## Build and destroy your workspace

Apples and oranges, dogs and horses, you can model practically everything in R. The only limit is your own imagination! However, how you create and manage the variables you're creating is always the same. If fruits are not your kind of thing, you're in luck! In this challenge, you will compute the volume of a donut. The volume of a donut can be expressed as:

$$V = 2 \pi^2 r^2 R$$

where $r$ is the minor radius and $R$ is the major radius. This is the same as computing the area of the cylindrical portion of the donut ($\pi r^2$) and multiplying it by the circumference of the donut ($2 \pi R$). Top off this theory with some workspace management and you've got one tasty challenge! One last tip: $\pi$ is available in R by default as `pi`.

_Type and execute code in the console. DataCamp will automatically grade each submission to see if you solved the challenge. Try not to click on the intermediate steps, as they cost you XP points. The challenge description in the goal should suffice!_

*** =challenge_steps
## Define the inner and outer radius
Define the variable `r` and `R` and set them to 2 and 6 using the assignment operator (`<-`).

## Calculate the cilinder area
Calculate the area of the cilindrical portion of the donut as `pi*r^2` and assign the variable to `ar_donut`. Inspect the resulting variable.

## Calculate the donut circumference
Calculate the circumference of the donut as `2*pi*R` and assign the variable to `cir_donut`. Inspect the resulting variable.

## Calculate the donut volume
Calculate the volume of the donut as the product of `ar_donut` and `cir_donut` and assign the result to a variable `vol_donut`.

## Clean up the workspace
Remove all intermediary variables that you've used to calculate `vol_donut` using the [`rm()`](http://www.rdocumentation.org/packages/base/functions/rm) function. Finally, use [`ls()`](http://www.rdocumentation.org/packages/base/functions/ls) to list the resulting workspace. It should only contain `vol_donut`.

*** =challenge_goal
## Calculate the donut volume
Create the variables `r` and `R`, equal to 2 and 6 respectively, to calculate the volume of the donut, `vol_donut`. Remove all the intermediary variables that you've used to calculate `vol_donut` such that only the variable `vol_donut` remains. Finally, inspect the workspace you end up with.

*** =pre_exercise_code
```{r}
# no pec
```

*** =solution
```{r}
r <- 2
r
R <- 6
R
ar_donut <- pi * r ^ 2
ar_donut
cir_donut <- 2 * pi * R
cir_donut
vol_donut <- ar_donut * cir_donut
rm(r, R, ar_donut, cir_donut)
ls()
```

*** =sct
```{r}
test_instruction(1, {
  test_error()
  assign("r", 2, envir = get_solution_env())
  test_object("r")
  rm(r, envir = get_solution_env())
  assign("R", 6, envir = get_solution_env())
  test_object("R")
  rm(R, envir = get_solution_env())
})
test_instruction(2, {
  test_error()
  assign("ar_donut", pi*2^2, envir = get_solution_env())
  test_or(
    test_an_object("ar_donut"),
    test_output_contains("pi*2^2")
  )
  rm(ar_donut, envir = get_solution_env())
})
test_instruction(3, {
  test_error()
  assign("cir_donut", 2*pi*6, envir = get_solution_env())
  test_or(
    test_an_object("cir_donut"),
    test_output_contains("2*pi*6")
  )
  rm(cir_donut, envir = get_solution_env())
})
test_instruction(4, {
  test_error()
  test_object("vol_donut")
})
test_instruction(5, {
  test_error()
  test_object("vol_donut")
  test_output_contains("\"vol_donut\"")
})
test_instruction(6, {
  test_error()
  test_object("vol_donut")
  test_output_contains("\"vol_donut\"")
})
success_msg("Awesome! In this challenge, the true power of variables became apparent.")
```


--- type:ChallengeExercise lang:r xp:200 skills:1
## Coercion for the sake of cleaning

Coercion can come in pretty handy when you're dealing with messy datasets where supposedly numerical variables have been stored as character strings, logicals have been stored as numerics etc. To prepare you for such problems, take this challenge: your first modest steps in data cleaning! In the workspace, some variables concerning the answers on a questionnaire have been defined; have a look with [`ls()`](http://www.rdocumentation.org/packages/base/functions/ls).

_Type and execute code in the console. DataCamp will automatically grade each submission to see if you solved the challenge. Try not to click on the intermediate steps, as they cost you XP points. The challenge description in the goal should suffice!_

*** =challenge_steps
## Convert the age to a numeric
Use [`as.numeric()`](http://www.rdocumentation.org/packages/base/functions/numeric) to convert the character `age`; assign the result to a new variable `age_clean`.

## Convert employed to a logical
With the help of [`as.logical()`](http://www.rdocumentation.org/packages/base/functions/logical), convert the numeric `employed` and store the result to a new variable `employed_clean`.

## Convert the salary to a numeric
Using the [`as.numeric()`](http://www.rdocumentation.org/packages/base/functions/numeric) function, convert the respondent's `salary` to a numeric; assign the resulting numeric to the variable `salary_clean`.

*** =challenge_goal
## Clean the questionnaire data
In the questionnaire data, there are three variables that do not have the correct types. Create three new variables, `age_clean`, `employed_clean` and `salary_clean` that contain the correct information in the most meaningful format (e.g. numeric for numbers).

*** =pre_exercise_code
```{r}
# no pec
age <- "29"
employed <- 1
location <- "Paris"
salary <- "63394.12"
```

*** =solution
```{r}
age_clean <- as.numeric(age)
employed_clean <- as.logical(employed)
salary_clean <- as.numeric(salary)
```

*** =sct
```{r}
test_instruction(1, {
  test_error()
  test_object("age_clean")
})
test_instruction(2, {
  test_error()
  test_object("employed_clean")
})
test_instruction(3, {
  test_error()
  test_object("salary_clean")
})
test_instruction(4, {
  test_error()
  test_object("age_clean")
  test_object("employed_clean")
  test_object("salary_clean")
})
success_msg("Perfect! Sit back and relax for a while after this first introduction to R, but not for too long: there is much more to come!")
```


--- type:ChallengeExercise lang:r xp:200 skills:1
## First steps in rational gambling

In the previous exercise, you found out that roulette is not really your forte. However, you have some vague memories from visits in Vegas where you actually excelled at this game. You plan to dig through your receipts of when you withdrew and cashed chips and found out about your actual performance in the previous week you were in Sin City. In that week, you also only played poker and roulette; the information is stored in `poker_past` and `roulette_past`. The information for the current week, with which you have been working all along, is in `poker_present` and `roulette_present`. All these variables are available in your workspace.

*** =challenge_steps
## Calculate the total gains for the past
Use the [`sum()`](http://www.rdocumentation.org/packages/base/functions/sum) function twice in combination with the `+` operator to calculate the total gains for your entire past week in Vegas (this means for both poker and roulette). Assign the result to `total_past`

## Calculate difference of past to present poker performance
Using the `-` operator, subtract `poker_past` from `poker_present`, to calculate `diff_poker`.

## Were you better at roulette before?
Use the [`sum()`](http://www.rdocumentation.org/packages/base/functions/sum) function twice and the `>` operator to see whether you were better in roulette in the past than you are in the current week. Assign the result to `roulette_worsened`.

*** =challenge_goal
## Compare your past performance to your current performance
To better compare your performance, perform the following calculations:
- Calculate what you have earned (or lost) on roulette and poker in the past week. Assign the result to `total_past`.
- Find the daily difference in poker performance between your current week and the past week; store the result in a variable `diff_poker`.
- Create a logical that tells whether your total winnings of roulette winnings in the past were higher than your total winnings in the current week. Assign the result to `roulette_worsened`.

*** =pre_exercise_code
```{r}
days_vector <- c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday")
poker_present <- c(140, -50, 20, -120, 240)
names(poker_present) <- days_vector
roulette_present <- c(-24, -50, 100, -350, 10)
names(roulette_present) <- days_vector
poker_past <- c(-70, 90, 110, -120, 30)
roulette_past <- c(20, 45, 120, -230, 40)
```

*** =solution
```{r}
total_past <- sum(poker_past) + sum(roulette_past)
diff_poker <- poker_present - poker_past
roulette_worsened <- sum(roulette_past) > sum(roulette_present)
```

*** =sct
```{r}
test_instruction(1, {
  test_error()
  test_an_object("total_past")
})
test_instruction(2, {
  test_error()
  test_an_object("total_past")
  test_an_object("diff_poker")
})
test_instruction(3, {
  test_error()
  test_an_object("total_past")
  test_an_object("diff_poker")
  test_an_object("roulette_worsened")
})
test_instruction(4, {
  test_error()
  test_an_object("total_past")
  test_an_object("diff_poker")
  test_an_object("roulette_worsened")
})
success_msg("Awesome! It seems that indeed, your roulette skills have worsened if you compare to your previous week in Vegas.")
```

--- type:ChallengeExercise lang:r xp:200 skills:1
## Vectors: place your bets!

By now, you should have gained some insights on how your casino habits are actually working out for you. In fact, why not decide on changing your game completely? Let's dive into the world of Blackjack for once, and analyze some game outcomes here. In short, blackjack is a game where you have to ask for cards until you arrive at a sum that is as close to 21 as possible. However, if you exceed 21, you've lost. You can be greedy and go for 21, or you can be careful and settle for 16 or so. A player wins when his or her sum, or score, exceeds that of the house. 

The sums for the player's last 7 games are stored in `player`; the house's scores are contained in `house`. Both are available in the workspace. In both cases, the scores were never higher than 21.

*** =challenge_steps
## Select player score for the third game
With square brackets, select the player's score for the third game, using any of the techniques that you've learned about. Store the result in `player_third`.

## Select winning scores
Subset the `player` vector to only select the scores that exceeded the scores of `house`, so the scores that had the player win. Use subsetting in combination with the relational operator `>`. Assign the subset to the variable `winning_scores`.

## Count poor scores
Count the number of times the score inside `player` was lower than 18. This time, you should use a relational operator in combination with [`sum()`](http://www.rdocumentation.org/packages/base/functions/sum). Save the resulting value in a new variable, `n_low_score`.

*** =challenge_goal
## Analyze the Blackjack results
- Select the player's score for the third game; store the result in `player_third`.
- Subset `player` to select only scores that led to the player winning from the house. Save the result in `winning_scores`.
- Count the number of times the player had a score lower than 18 and save this value in `n_low_score`.  

*** =pre_exercise_code
```{r}
player <- c(14,17,20,21,20,18,14)
house <- c(20,15,21,20,20,17,19)
```

*** =solution
```{r}
player_third <- player[3]
winning_scores <- player[player > house]
n_low_score <- sum(player < 18)
```

*** =sct
```{r}
test_instruction(1, {
  test_error()
  test_an_object("player_third")
})
test_instruction(2, {
  test_error()
  test_an_object("player_third")
  test_an_object("winning_scores")
})
test_instruction(3, {
  test_error()
  test_an_object("player_third")
  test_an_object("winning_scores")
  test_an_object("n_low_score")
})
test_instruction(4, {
  test_error()
  test_an_object("player_third")
  test_an_object("winning_scores")
  test_an_object("n_low_score")
})
success_msg("Awesome! Given that you've solved this challenge so gracefully, you might consider adding Blackjack to your playlist on your next trip to Vegas! This challenge concludes the chapter on vectors. The next chapter will introduce you to the two-dimensional version of vectors: matrices.")
```

--- type:ChallengeExercise lang:r xp:200 skills:1
## Matrices: Move it up a notch

You'll be surprised of all the matrix magic that you can already perform after these exercises. Suppose that next to being a huge Star Wars fan, you also relish Japanese horror movies. The interest for this genre is rather limited though. To share your passion you decide to convert your garage to a home theater with 24 seats, 4 rows of 6 seats each. After showing your all-time favorites, you ask the audience to grade the movies they saw. The voting results for each row are stored in the vectors `first_row`, `second_row`, `third_row` and `fourth_row`. Up to you to do some analysis on them!

*** =challenge_steps
## Build the theater matrix
Using `rbind()` and the four vectors that are already in your workspace, create the matrix theater, that contains all these vectors in the correct order.

## Calculate the row-wise sums
Use `rowSums()` to calculate the row-wise sums of the matrix that contains all the voting results. Assign the result to a variable `row_scores`.

## Merge the row scores with the theater matrix
Use `cbind()`, this time to paste the matrix of the theater scores with the row-wise sums. It should be added as the last column of `scores`.

## Name the scores matrix
Use the `colnames()` and `rownames()` functions to name the scores. For the rows, you'll need a vector of length 4 to set the names; for the columns, you'll need a vector of length 7.

*** =challenge_goal
## Build and name the scores matrix
Create a new matrix, `scores`, by following these instructions:
- Make a matrix containing 4 rows, corresponding to the 4 rows in your home theater. Call it `scores`.
- Make a vector containing the sums of the scores in each row. Call it `row_scores`.
- Add `row_scores` as a column in `scores`.
- Name `scores`:
  + Rows: "row1", "row2", "row3" and "row4".
  + Columns: "c1", "c2", "c3", "c4", "c5", "c6" and "total".

*** =pre_exercise_code
```{r}
first_row <- c(6,8,7,9,9,10)
second_row <- c(6,8,7,5,9,6)
third_row <- c(5,4,6,6,7,8)
fourth_row <- c(4,5,3,4,6,8)
```

*** =solution
```{r}
theater <- rbind(first_row, second_row, third_row, fourth_row)
row_scores <- rowSums(theater)
scores <- cbind(theater, row_scores)
rownames(scores) <- c("row1", "row2", "row3", "row4")
colnames(scores) <- c("c1", "c2", "c3","c4", "c5", "c6", "total")
```

*** =sct
```{r}
test_instruction(1, {
  test_error()
  test_an_object("theater")
})
test_instruction(2, {
  test_error()
  test_an_object("row_scores")
})
test_instruction(3, {
  test_error()
  test_an_object("scores")
})
test_instruction(4, {
  test_error()
  test_an_object("scores", eq_condition = "equal")
})
test_instruction(5, {
  test_error()
  test_an_object("scores", eq_condition = "equal")
})
success_msg("Bellissimo! It seems that the people in front clearly enjoyed the videos more, it's all about the details in Japanese horror! Although vector are very similar to matrices, subsetting is quite different because of the additional dimension.")
```

--- type:ChallengeExercise lang:r xp:200 skills:1
## Subsetting: The final challenge

After all these exercises on Star Wars, you start a conversation about it with your friends. Before you realize it, a big discussion has started about who is the biggest fan, with three people claiming to be true adepts. Time to sort this out. You decide to collect data by asking everyone how often they have seen each of the movies. To keep things structured, you stored the information in two parts. The view counts for four people are in `view_count_1`, the counts for four other people are in `view_count_2`.
The next day you do an analysis to see which of the three loud mouths of the previous night has seen the most Star Wars movies. With your new knowledge about matrices, this could be a walk in the park! `view_count_1` and `view_count_2` are available in the workspace.

*** =challenge_steps
## Combine the two matrices
Combine the matrices `view_count_1` and `view_count_2` in a new matrix, `view_count_all`, using `cbind()`.

## Subset the information on the three loudest debaters
From the matrix containing all view count information, subset the view counts for the three loudest debaters (Rachel, Walter and Dave). You can use subsetting by indices, names or a logical vector here. Store the result in the matrix `view_count_loud`.

## Calculate the total number of views of loudest debaters
Use the function `colSums()` to calculate the total number of times the loud debaters have seen any of the Star Wars movies. Store the result in a vector in `total_views_loud`.

*** =challenge_goal
## Sort it out, once and for all
Using a combination of matrix operations, create a vector, `total_views_loud`, that contains the total number of times each one of the 3 loudest debaters - Rachel, Walter and Dave - have seen the Star Wars movies.

*** =pre_exercise_code
```{r}
movie_names <- c("A New Hope", "The Empire Strikes Back", "Return of the Jedi","The Phantom Menace", "Attack of the Clones", "Revenge of the Sith")
Mark <- c(1,2,1,1,1,0)
Laurent <- c(3,4,3,2,1,1)
Rachel <- c(2,3,2,1,0,0)
Pierre<-c(3,2,1,1,1,0)
first_names <- c("Mark", "Laurent", "Rachel", "Pierre")
view_count_1 <- cbind(Mark,Laurent,Rachel,Pierre)
colnames(view_count_1) <- first_names
rownames(view_count_1) <- movie_names

Christel <- c(2,2,2,4,5,4)
Walter <- c(1,1,0,2,3,1)
Dave <- c(5,2,3,2,2,3)
Monica <-c(0,0,0,0,0,1)
second_names <- c("Christel", "Walter", "Dave", "Monica")
view_count_2 <- cbind(Christel, Walter, Dave, Monica)
colnames(view_count_2) <- second_names
rownames(view_count_2) <- movie_names

rm(movie_names, Mark, Laurent, Rachel, Pierre, Christel, Walter, Dave, Monica, first_names, second_names)
```

*** =solution
```{r}
view_count_all <- cbind(view_count_1, view_count_2)
view_count_loud <- view_count_all[,c(3,6,7)]
total_views_loud <- colSums(view_count_loud)
```

*** =sct
```{r}
test_instruction(1, {
  test_error()
  test_object("view_count_1")
  test_object("view_count_2")
  test_or(
    test_an_object("view_count_all"),
    test_output_contains("cbind(view_count_1, view_count_2)")
  )
})
test_instruction(2, {
  test_error()
  test_object("view_count_1")
  test_object("view_count_2")
  test_or(
    test_an_object("view_count_loud"),
    test_output_contains("cbind(view_count_1, view_count_2)[,c(3,6,7)]")
  )
})
test_instruction(3, {
  test_error()
  test_object("view_count_1")
  test_object("view_count_2")
  test_or(
    test_an_object("view_count_loud"),
    test_output_contains("colSums(cbind(view_count_1, view_count_2)[,c(3,6,7)])")
  )
})
test_instruction(4, {
  test_error()
  test_object("view_count_1")
  test_object("view_count_2")
  test_or(
    test_an_object("view_count_loud"),
    test_output_contains("colSums(cbind(view_count_1, view_count_2)[,c(3,6,7)])")
  )
})
success_msg("Awesome! If you look at the results, you'll see that Dave is the true Star Wars connaisseur here! Up to the next video on matrices!")
```

--- type:ChallengeExercise lang:r xp:200 skills:1
## May the matrix force be with you!

After these analyses, you sure have gained some more insights in the movie-making business! But box office figures don't tell the whole story, do they? Up to you to take into account the actual budget that went into creating the films, together with commissions by the movie theaters worldwide. That way, you'll have a better idea about the actual profits StarWarsStudios has realized.

The commission rates that theaters ask for the three different films differ per film as well as per region; they're stored in `commission_rates`. The budget for the three films is stored in a named vector `budget`. Together with the `star_wars_matrix` that you've been working with all along, these variables are available in the workspace.

*** =challenge_steps
## Subtract the commission
Using `star_wars_matrix`, `commission_rates`, multiplication and subtraction, calculate the money that remains after the theaters' commission is subtracted. Store the result in a variable `remaining`. The commision on a film can be calculated by multiplying the movie box office figure with the commission rate.

## Calculate the remaining income per film
Using `rowSums()` on `remaining`, calculate the total remaning income per film and assign the outcome to a new vector, `remaining_tot`. Print it out to have a look.

## Subtract the budget
Finally, subtract the per film budget from the remaning income per film to end up with a variable `profit`.

*** =challenge_goal
## Calculate the StarWarsStudios profit
Calculate the amount of money StarWarsStudios made per film by
- subtracting the theaters' commission on a per film and per region basis (`remaining`), 
- calculating the remaining income per film (`remaining_tot`) and finally 
- subtracting the budget from that. 
Store the final result in a variable `profit`.

*** =pre_exercise_code
```{r}
box_office_all <- c(461, 314.4, 290.5, 247.9, 309.3, 165.8)
movie_names <- c("A New Hope","The Empire Strikes Back","Return of the Jedi")
col_titles <- c("US","non-US")
star_wars_matrix <- matrix(box_office_all, nrow = 3, byrow = TRUE, dimnames = list(movie_names, col_titles))
commission_rates <- matrix(c(0.25, 0.28, 0.23, 0.26, 0.2, 0.21), nrow = 3, byrow = TRUE, dimnames = list(movie_names, col_titles))
budget <- c(13, 18, 32.5)
names(budget) <- movie_names
```

*** =solution
```{r}
remaining <- star_wars_matrix - commission_rates * star_wars_matrix
remaining
remaining_tot <- rowSums(remaining)
remaining_tot
profit <- remaining_tot - budget
```

*** =sct
```{r}
test_instruction(1, {
  test_error()
  test_object("star_wars_matrix")
  test_object("commission_rates")
  test_or(
    test_an_object("remaining"),
    test_output_contains("star_wars_matrix - commission_rates * star_wars_matrix")
  )
})
test_instruction(2, {
  test_error()
  test_object("star_wars_matrix")
  test_object("commission_rates")
  test_or(
    test_an_object("remaining_tot"),
    test_output_contains("rowSums(star_wars_matrix - commission_rates * star_wars_matrix)")
  )
})
test_instruction(3, {
  test_error()
  test_object("star_wars_matrix")
  test_object("commission_rates")
  test_object("budget")
  test_or(
    test_an_object("profit"),
    test_output_contains("rowSums(star_wars_matrix - commission_rates * star_wars_matrix) - budget")
  )
})
test_instruction(4, {
  test_error()
  test_object("star_wars_matrix")
  test_object("commission_rates")
  test_object("budget")
  test_or(
    test_an_object("profit"),
    test_output_contains("rowSums(star_wars_matrix - commission_rates * star_wars_matrix) - budget")
  )
})
success_msg("Now that's true R force! Great! This challenge concludes the part on matrices. Next up: factors!")
```

--- type:ChallengeExercise lang:r xp:200 skills:1
## Flying high in factor space

As a data analyst, you decide to join Rways, a new airline that only offers flights and services based on data-driven decisions. Business is going well, and the management is considering to extend the offer from only economy class to business and first class as well. You are supposed to process the results of a questionnaire that polls for the preferred class of the respondents. The results for 50 of these respondents can be found in a character vector `fly_class`.

*** =challenge_steps
## Encode fly_class as a factor
Using the `factor()` function, convert `fly_class` to a factor, `fly_class_factor`.

## Set the correct factor levels and order the factor
By specifying more arguments inside the `factor()` function, i.e. `levels`, `ordered` and `labels`, change the display names of the factor levels and add an order the factor, going from "economy" to "first". Again, store the result in a factor `fly_class_factor`.

*** =challenge_goal
## Factorize the questionnaire data
Convert the `fly_class` vector to a factor, `fly_class_factor`. The display names of the different categories should be `"economy"`, `"business"` and `"first"`. Use a combination of `levels` and `labels` to achieve this. Finally, order the factors if this is appropriate in this context.

*** =pre_exercise_code
```{r}
set.seed(123)
fly_class <- c("eco", "bus", "fir")[sample(x = c(1,2,3), 50, prob = c(0.7, 0.2, 0.1), replace = TRUE)]
```

*** =solution
```{r}
fly_class_factor <- factor(fly_class, 
                           levels = c("eco", "bus", "fir"), 
                           ordered = TRUE, 
                           labels = c("economy", "business", "first"))
```

*** =sct
```{r}
test_instruction(1, {
  test_error()
  test_object("fly_class_factor")
  test_what(expect_true(is.factor(get("fly_class_factor", envir = globalenv(), inherits = FALSE))), feedback_msg = "none")
})
test_instruction(2, {
  test_error()
  test_object("fly_class_factor")
  test_what(expect_equal(levels(get("fly_class_factor", envir = globalenv(), inherits = FALSE)), c("economy", "business", "first")), feedback_msg = "FALSE")
})
test_instruction(3, {
  test_error()
  test_object("fly_class_factor")
  test_what(expect_equal(levels(get("fly_class_factor", envir = globalenv(), inherits = FALSE)), c("economy", "business", "first")), feedback_msg = "FALSE")
})
success_msg("Factiolicious! This challenge shows the true power of the `factor()` function: if you want, you can create a factor, but also order and rename the factor levels, all in a single command.")
```

--- type:ChallengeExercise lang:r xp:200 skills:1
## List your skills

Your R skills are growing at a staggering pace. Time to list them all! The topics that have been covered so far are contained in the vector `top`. There's also a factor, `cont`, that tells whether these skills relate to a data structure or more to R in general. Finally, the matrix `prop` summarizes some properties of vectors, matrices, factors and lists. 

These three variables - `top`, `cont` and `prop` - are already defined in the workspace. Up to you to put them all together. This is a pretty self rewarding exercise, right?

*** =challenge_steps
## Create list
Subset both `top` and `prop` with single square brackets and add the selections to a new list, `lst`, using the `list()` function. To subset the matrix, you'll need `[,4]`.

## Create and name skills
Build a list `skills` with the `list()` function. It should contain `top`, `cont`, `prop` and `lst` (in this order).
You can choose to first create the list with `list()` and name the list afterwards with `names()`. You can also build a named list in a single command with the following syntax:
```
list(name1 = el1, name2 = el2, ...).
```

## Display the structure of skills
Use the `str()` function on `skills` to display the structure.

*** =challenge_goal
## Merge your skills and display them!
- Create a list `lst`, that contains the fifth element from `top` and the entire fourth column of `prop`. Do not name this list.
- Create a new list, `skills`, that contains `top`, `cont`, `prop` and `lst`. Name the list elements `topics`, `context`, `properties` and `list_info`, respectively. 
- Finally, displays the structure of `skills`.

*** =pre_exercise_code
```{r}
top <- c("basic data type","vectors","matrices","factors","lists")
cont <- factor(c("core", "data", "data", "data", "data"))
rwnms <- c("1D", "heterogeneous", "subsetting", "calculus")
clnms <- c("vector", "matrix", "factor", "list")
prop <- matrix(c(T, F, T, T,
                 F, F, T, T,
                 T, F, T, F,
                 T, T, T, F), nrow = 4, dimnames = list(rwnms, clnms))
rm(rwnms, clnms)
```

*** =solution
```{r}
lst <- list(top[5], prop[, 4])
skills <- list(topics = top, context = cont, properties = prop, list_info = lst)
str(skills)
```

*** =sct
```{r}
test_instruction(1, {
  test_error()
  test_object("top")
  test_object("prop")
  test_or(
    test_an_object("lst"),
    test_output_contains("list(top[5], prop[, 4])")
  )
})
test_instruction(2, {
  test_error()
  test_object("top")
  test_object("prop")
  test_or(
    test_an_object("skills", eq_condition = "equal"),
    test_output_contains("list(topics = top, context = cont, properties = prop, list_info = list(top[5], prop[, 4]))")
  )
})
test_instruction(3, {
  test_error()
  test_or(
    test_function("str", "object"),
    test_output_contains("str(list(topics = top, context = cont, properties = prop, list_info = list(top[5], prop[, 4])))")
  )
})
test_instruction(4, {
  test_error()
  test_or(
    test_function("str", "object"),
    test_output_contains("str(list(topics = top, context = cont, properties = prop, list_info = list(top[5], prop[, 4])))")
  )
})
success_msg("Congratulations! You nailed yet another challenge!")
```

--- type:ChallengeExercise lang:r xp:200 skills:1
## List your skills (2)

Remember the `skills` list that you coded in the previous challenge? It contains a vector, a factor, a matrix and another list. It can't get any more diverse, can it? The `skills` list is already available in your workspace, with the appropriate naming. Now it's your turn: rebuild the list and select all necessary bits and pieces from it.

*** =challenge_steps
## Select second element from topics
Using a combination of list subsetting and vector/factor subsetting, select the second element from both the `topics` element inside `skills`. Use this template: `skills$name[index]`. Print it out to the console.

## Select second element from context
Using a combination of list subsetting and vector/factor subsetting, select the second element from both the `context` element inside `skills`. Use this template: `skills$name[index]`. Print it out to the console.

## Pick the entire vector from list_info
Using list subsetting twice, select the second element inside `list_info`, which is the fourth element in `skills`.

## Put all subsets in a list
After correctly performing all subsetting operations, combine the calls inside the `list()` function to create the variable `key_skills`.

*** =challenge_goal
## What skills are key?
Use subsetting techniques to select the following elements from `skills` (in this order):
- The second element of the `topics` vector,
- The second element of the `context` factor,
- The last element of the logical vector inside the `list_info`.

Finally group the elements you selected in the previous steps in a new list, `key_skills`.

*** =pre_exercise_code
```{r}
top <- c("basic data type","vectors","matrices","factors","lists")
cont <- factor(c("core", "data", "data", "data", "data"))
rwnms <- c("1D", "heterogeneous", "subsetting", "calculus")
clnms <- c("vector", "matrix", "factor", "list")
prop <- matrix(c(T, F, T, T,
                 F, F, T, T,
                 T, F, T, F,
                 T, T, T, F), nrow = 4, dimnames = list(rwnms, clnms))
lst <- list(top[5], prop[,4])
skills <- list(topics = top, context = cont, properties = prop, list_info = lst)
rm(top, cont, rwnms, clnms, prop, lst)
```

*** =solution
```{r}
passed1 <- runif(10)
passed2 <- runif(10)
s1 <- skills$topics[2]
s2 <- skills$context[2]
s3 <- skills$list_info[[2]][4]
key_skills <- list(skills$topics[2], skills$context[2], skills$list_info[[2]][4])
```

*** =sct
```{r}
test_instruction(1, {
  test_error()
  test_or(
    test_an_object("s1"),
    test_output_contains("skills$topics[2]")
  )
  # Need feature to check whether previous instrctuions are passed. This solution is dirty.
  assign("passed1", get("passed1", get_solution_env()), .GlobalEnv)
})
test_instruction(2, {
  test_error()
  test_object("passed1")
  test_or(
    test_an_object("s2"),
    test_output_contains("skills$context[2]")
  )
  assign("passed2", get("passed2", get_solution_env()), .GlobalEnv)
})
test_instruction(3, {
  test_error()
  test_object("passed2")
  test_or(
    test_an_object("s3"),
    test_output_contains("skills$list_info[[2]][4]")
  )
})
test_instruction(4, {
  test_error()
  test_or(
    test_an_object("key_skills"),
    test_output_contains("list(skills$topics[2], skills$context[2], skills$list_info[[2]][4])")
  )
})
test_instruction(5, {
  test_error()
  test_or(
    test_an_object("key_skills"),
    test_output_contains("list(skills$topics[2], skills$context[2], skills$list_info[[2]][4])")
  )
})
success_msg("Great! Quite some skills you've got there! Learn all about data frames in the next chapter")
```

--- type:ChallengeExercise lang:r xp:200 skills:1
## Rule the world!

You have now gained the power to create, name and present your own data frame, congratulations! Now let's put those skills to the test.

Suppose you have made a selection of countries throughout the whole world. For these countries you have collected some key variables (geographical, economical and political):

- Name of the country (`countries`),
- Continent in which the country lies (`continents`),
- Nominal GDP per capita of the country (`gdp`),
- Human Development Index of the country (`hdi`),
- Whether the country has a president (`president`)

After consulting the all-knowing oracle (Wikipedia) again, you managed to create some vectors (listed inside parentheses). All these vectors are already available in the workspace. That means that everything is set now to create your own dataset, Let's make this happen!

*** =challenge_steps
## Encode continents as a factor
The continent information is categorical: create a new variable `continents_factor` that is the result of encoding `continents`.

## Create countries_df
Using the `data.frame()` function, build a data frame, `countries_df`, with all the listed variables. Make sure to use `continents_factor` instead of `continents` here! Specify the `stringsAsFactors` argument correctly.

## Name countries_df appropriately
Either by adapting the `data.frame()` function call or by using the `names()` function, give the appropriate names to all columns in `countries_df`.

## Display the structure of countries_df
As you already did countless times before, display the structure of `countries_df` with the `str()` function to assert that you have correctly created the data frame.

*** =challenge_goal
## Create the countries data frame
Create a new data frame, `countries_df`, containing all the listed information in that order. Name the column names "name", "cont", "GDP", "HDI" and "has_president", respectively. Make sure that the first column is a character vector, while the second one is a factor. To finish off, display the structure of the structure of `countries_df`.

*** =pre_exercise_code
```{r}
countries <-c("Canada", "United States", "France", "Belgium", "India", "China", "United Kingdom", "Russia")
continents <-c("North-America", "North-America", "Europe", "Europe", "Asia", "Asia", "Europe", "Asia")
gdp <- c(44843, 54596, 44538, 47787, 1808, 8154, 45653, 8184)
hdi <- c(0.902, 0.914, 0.884, 0.881, 0.586, 0.719, 0.892, 0.778)
president <- c(F, T, T, F, T, T, F, T)
```


*** =solution
```{r}
continents_factor <- factor(continents)
countries_df <- data.frame(name = countries, cont = continents_factor, GDP = gdp, HDI = hdi, has_president = president, stringsAsFactors=FALSE)
str(countries_df)
```

*** =sct
```{r}
test_instruction(1, {
  test_error()
  test_an_object("continents_factor")
})
test_instruction(2, {
  test_error()
  test_an_object("countries_df")
})
test_instruction(3, {
  test_error()
  test_an_object("countries_df", eq_condition = "equal")
})
test_instruction(4, {
  test_error()
  test_or(
    test_function("str","object"),
    test_output_contains("str(data.frame(name = countries, cont = factor(continents), GDP = gdp, HDI = hdi, has_president = president, stringsAsFactors=FALSE))")
  )
})
test_instruction(5, {
  test_error()
  test_or(
    test_function("str","object"),
    test_output_contains("str(data.frame(name = countries, cont = factor(continents), GDP = gdp, HDI = hdi, has_president = president, stringsAsFactors=FALSE))")
  )
})
success_msg("Congratulations!")
```

--- type:ChallengeExercise lang:r xp:200 skills:1
## Rule the world: part II 
Remember that in the previous challenge you created your own data frame, `countries_df`? Well, in this challenge you will get to play around with this data frame some more! Suppose you are no longer interested in the economic variables `gdp` and `hdi`. Instead you want to learn more about the demography of the countries. Also, since you are planning a trip to Brazil this summer, you want to include some information on this country to your data frame. Finally, you want to keep the overview and have the countries with the largest population appear first in your data frame. Sounds like an easy job after completing the previous set of exercises, right?

*** =challenge_steps
## Remove and add columns
Subset `countries_df` to drop the columns `gdp` and `hdi`. You can use single brackets for this. Next, add the variable `population` to your dataframe. Again, there are several ways to do this; one way is to use the `cbind()` function. Store the resulting data frame again `countries_df_dem`.

## Add brazil to the data frame
Include the data on your future holiday destination: Brazil. This comes down to adding a new observation, so you have to make sure that the names of `brazil` match those in `countries_df_dem`. Next you can use the `rbind()` function to merge the dataframes into the new dataframe `countries_df2`.

## Sort your data frame
All that is left to do is sort the observations according to population size. Note that you want the largest population to be represented first. Therefore, you'll need `order()` with the `decreasing` argument equal to `TRUE`. Just print it, do not overwrite the `countries_df2` dataframe.

*** =challenge_goal
## Subset and extend your data frame
Create a new data frame, `countries_df_dem`, that no longer contains the economic variables `gdp` and `hdi`, but has the additional `population` column (a vector `population` is available in the workspace). Extend `countries_df_dem` further by adding the information on Brazil (a data frame `brazil` is available in the workspace but it is not named correctly yet). Call the resulting data frame `countries_df2`. Finally, print a sorted version `countries_df2` such that the country with the largest population comes first. Just print it; do not overwrite the `countries_df2` dataframe.

*** =pre_exercise_code
```{r}
countries <-c("Canada", "United States", "France", "Belgium", "India", "China", "United Kingdom", "Russia")
continents <-c("North-America", "North-America", "Europe", "Europe", "Asia", "Asia", "Europe", "Asia")
gdp <- c(44843, 54596, 44538, 47787, 1808, 8154, 45653, 8184)
hdi <- c(0.902, 0.914, 0.884, 0.881, 0.586, 0.719, 0.892, 0.778)
president <- c(F, T, T, F, T, T, F, T)
continents_factor <- factor(continents)
countries_df <- data.frame(name = countries, continent = continents_factor, gdp = gdp, HDI = hdi, has_president = president, stringsAsFactors=FALSE)
rm(countries, continents, gdp, hdi, president, continents_factor)
population<-c(35749600, 321163157, 66616416, 11239755, 1210193422, 1357380000, 64511000, 143975923)
brazil<-data.frame("Brazil", "South-America", TRUE, 202768562)
```

*** =solution
```{r}
# Remove economic variables and add population.
countries_df_dem <- countries_df[ , c(1, 2, 5)]
countries_df_dem$population <- population

# Add brazil
names(brazil) <- c("name", "continent", "has_president", "population")
countries_df2 <- rbind(countries_df_dem,brazil)

# Sort by population
countries_df2[order(countries_df2$population,decreasing=TRUE), ]
```

*** =sct
```{r}
test_instruction(1, {
  test_error()
  test_an_object("countries_df_dem")
})
test_instruction(2, {
  test_error()
  test_an_object("countries_df2")
})
test_instruction(3, {
  test_error()
  test_output_contains("countries_df2[order(countries_df2$population,decreasing=TRUE), ]", env = get_solution_env())
})
test_instruction(4, {
  test_error()
  test_output_contains("countries_df2[order(countries_df2$population,decreasing=TRUE), ]", env = get_solution_env())
})
success_msg("Perfect! This challenge concludes the chapter on data frames. Remember that data frames are extremely important in R, you will need them all the time! Next stop: basic graphics in R!")
```